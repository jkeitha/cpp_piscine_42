## Summary: ##

- subtype polimorphism
- abstract classes
- interfaces

Полиморфизм - возможность объектов с одинаковой спецификацией иметь различную реализацию

Типы полиморфизма по Стрейчи:

- параметрический (parametric)
- специальный (ad-hoc)

Параметрический полиморфизм подразумевает исполнение одного и того же кода для всех допустимых типов, а специальный - подразумевает исполнение разного кода для каждого типа

Типы полиморфизма по Карделли:

- универсальный (universal)
   - параметрический (parametric)
   - подтипов (subtype)
- специальный (ad-hoc)
   - перегрузка (overloading) - например, перегрузка арифметических операторов
   - приведение типов (coercion) - например, приведение символьного типа к числовому

Универсальный полиморфизм позволяет работать с неограниченным количеством типов, а вот специальный - только с конечным набором конкретных типов

Полиморфизм подтипов - возможность через данный интерфейс использовать его подтипы, но при этом не знать этого. Например, если класс - это тип, то его потомки будут подтипами:

``` cpp
#include <iostream>

class Animal {
	public:
	virtual void speak() {
		std::cout << "???" << std::endl;
	}
};

class Cat : public Animal {
	public:
	virtual void speak() {
		std::cout << "meow" << std::endl;
	}
};

class Dog : public Animal {
	public:
	virtual void speak() {
		std::cout << "woof" << std::endl;
	}
};

void report(Animal &animal) { animal.speak(); }

int main() {
	Cat cat;
	Dog dog;

	report(cat);
	report(dog);
	return 0;
}
```

Не рекомендуется вызывать виртуальные функции в конструкторах или деструкторах

Чистая виртуальная функция - метод, который не имеет определения. Переопределением таких функций занимаются потомки.

``` cpp
class Parent {
	virtual void func() = 0;
};
```

Абстрактный класс - класс, который содержит хотя бы одну чистую виртуальную функцию. Создать экземпляр такого класса невозможно. Если класс-потомок не переопределит все чистые виртуальные функции родителя, то он так же, как и родитель, будет считаться абстрактным.

``` cpp
#include <iostream>

class Animal {
	public:
	virtual void speak() = 0; // чистая виртуальная функция
};

class Cat : public Animal {
	public:
	// переопределение чистой виртуальной функции
	virtual void speak() { std::cout << "meow" << std::endl; }
};

void report(Animal &animal) { animal.speak(); }

int main() {
	Cat cat;

	report(cat);
	return 0;
}
```

Интерфейс - класс, который не имеет свойств, и все методы которого являются чистыми виртуальными функциями.

### Копирование классов ###

Поверхностное копирование - почленный метод копирования, который подходит только для статически выделенной памяти. Если в конструкторе копирования использовать поверхностное копирование с динамически выделенной памятью, то деструктор очистит память членов обоих классов, так как были скопированы не значения, а адреса памяти.

При глубоком копировании, для копирования динамически выделенной памяти, нужно выделить память. Так память, выделенная в конструкторе копирования будет очищена деструктором, не задевая память класса, из которого была скопирована память.
